---
layout: post
tag: go-pills golang go
---
![pills all over there](pills-header.png)
# GO Programming Pills

* TOC
{:toc}

## :pill: #1: Forcing to use field names when instantiating structs

In GO, when instantiating a struct type you can use:
* _named fields_:  you name the fields you are assigning a value to, or
* _positional fields_: you let the position of the instantiation values define which field they correspond to

For example:

```go
type position struct {
	x int
	y int
}

func main() {
	p1 := position{y: 5, x: 10} // named instantiation
	p2 := position{10, 5}       // positional instantiation

	fmt.Printf("%+v == %+v", p1, p2)
}
```

The output of [executing the above code](https://go.dev/play/p/W6WWNrVgaJB) is:

```
{x:10 y:5} == {x:10 y:5}
```

Each initialization approach has its pros and cons and is up to you to decide which one to use when instantiating a struct type.

In cases like the above example, using positional initialization can lead to subtle bugs because the type of the two fields is the same, thus we can mix their values inadvertently when doing the instantiation.
As the developer of the type you might avoid instantiation errors by forcing users to use _named fields_... but how?!

Well there is a little hack: add a field with a blank (`_`) identifier at the beginning of the struct

```go
type position struct {
	_ struct{}  // just to force named fields in instantiation
	x int
	y int
}
```

Now, if you try to [run the code](https://go.dev/play/p/MXaGWWNxqMw) you will get the following **compilation** error for the expression `position{10, 5}`:

```
cannot use 10 (untyped int constant) as struct{} value in struct literal
too few values in struct literal
```

That does the trick and users will need (or prefer) to use named fields when instantiating your struct.

Anyway, do not forget that it is a _hack_ and that the compile error might be a little cryptic for some people.
Personally I prefer to use constructors even if they are not idiomatic in GO.

## :pill: #2: Are your struct tags OK?

In GO, _struct tags_ are used to annotate struct fields with meta-information.
Usually the meta-information helps data transformation libraries to marshall/unmarshall structs to/from some data representation format like JSON, XML, YAML, ...

For example, the following struct is annotated with meta-information for JSON and XML transformations:

```go
type User struct {
	ID   string `json:"id" xml:"identifier"`
	Name string `json:"name" xml:"name"`
}
```

Struct tags are one of the few ugliness of GO.
Tags are strings interpreted at runtime by using reflection.
Consequence: **the compiler is unable to catch errors in struct tags** :disappointed:

One very frequent error is JSON marshaling tags including `inline` option. For example:

```go
type UserContainer struct {
	apiv1.Container `json:",inline" protobuf:"bytes,1,opt,name=container"`
	// ...
}
```
([Argo](https://github.com/argoproj/argo-workflows/blob/1f1a1e0e9bfd1d6fe54146abd85e15ba80885768/pkg/apis/workflow/v1alpha1/workflow_types.go#L1516){:target="_blank" rel="noopener"})

```go
type ResourceMeta struct {
	TypeMeta `json:",inline" yaml:",inline"`
	// ...
}
```
([Kustomize](https://github.com/kubernetes-sigs/kustomize/blob/2fe04496c285bc2fa7a7233a7a584ab96e21f88d/kyaml/yaml/types.go#L139){:target="_blank" rel="noopener"})

The problem: `inline` option is not recognized by the standard [JSON library](https://pkg.go.dev/encoding/json), 
thus using it means nothing!

Another common problem in struct tags are typos.
Can you spot the problem in the code below?
```go
type LogicalProcessor struct {
        LpIndex     uint32 `json:"LogicalProcessorCount,omitempty"`
        NodeNumber  uint8  `json:"NodeNumber,omitempty"`
        PackageId   uint32 `json:"PackageId,omitemty"`
        CoreId      uint32 `json:"CoreId,omitempty"`
        RootVpIndex int32  `json:"RootVpIndex,omitempty"`
}
```
Did you see it?
The `omitem[p]ty` at the third field? :wink:

And to make things worst, using spaces in tags is tricky:
```go
`json:"metadata,omitempty"`  // OK
`json: "metadata,omitempty"` // Not OK
`json:"metadata, omitempty"` // Not OK
```
:scream: 
([here](https://go.dev/play/p/SYtEPFJUL_a){:target="_blank" rel="noopener"} you can see these problems in action)

As said before, the GO compiler will not help us with that.

We can use static code analysis tools (like [Revive](https://github.com/mgechev/revive){:target="_blank" rel="noopener"}) to detect these problems.

## :pill: #3: Multiple multiples

GO loves _multiples_. 
It has multiple return values, multiple variable assignment, multiple variable declaration.

The less uncommon feature is multiple variable declaration:

```go
var a, b, c int
```

declares (and initializes to the `int` _zero value_) three variables.
Nothing extraordinary.

Multiple variable assignment allows assigning multiple variables in a single assignment statement


```go
var a, b, c int
a, b, c = 1, 2, 3
```

of course the right hand of the assignment can be any expression and variable types do not need to be the same

```go
var a int
var b string
a, b = 1+25, fmt.Sprintf("the value of a is %d", a)
```
(can you guess the value of `b` after executing the assignment?)

When you combine multiple variable declaration and multiple assignment you can write things like

```go
var a, b, c = 1, 2, 3  	// declares three int variables 
		// with initial values 1, 2, and 3 respectively

var n, s = 4, "text"	// declares an int variable and a string variable
		// with initial values 4 and "text"
```
You can also use the `:=` operator to declare and assign at the same time

```go
a, b, c := 1, 2, 3	
n, s := 4, "text"
```

The third, and most interesting, _multiple_ of GO is _multiple return values_.
In GO functions can return multiple values. :alien:

```go
func randomCoords() (int, int) { ... }

x, y := randomCoords()
```

We can then write something like

```go
func newPoint(x, y int) point { return point{x, y} }

func randomCoords() (int, int) { ... }

func main() {
	x, y := randomCoords()
	p := newPoint(x, y)
	// ...
}
```
Further, GO lets us compose `newPoint` and `randomCoords` and replace the sequence:

```go
	x, y := randomCoords()
	p := newPoint(x, y)
```
by 

```go
	p := newPoint(randomCoords()) // look mum... no temporary vars!
```

Yes, GO verifies `randomCoords` return values match in number and type with `newPoint` arguments and it allows the function composition.

:broken_heart: Ugliness?: function composition works only if all the expected parameters are provided by a single function call used as argument.
For example:
```go
func new3DPoint(x, y, z int) point { ... }
func randomCoords() (int, int) { ... }
p3d := new3DPoint(0, randomCoords()) 	// does not compile
p3d := new3DPoint(randomCoords(),0) 	// does not compile

```

:broken_heart: Ugliness: multiple value expressions can not be used when instantiating structs.
For example:
```go
type point struct {
	x int
	y int
}
func randomCoords() (int, int) { ... }

p := point{randomCoords()}	// does not compile
```

Above examples are somewhat artificial because the concept of a _function_ returning more than one result does not match the mathematical concept of a function.
(functions returning more than one value might be the symptom of a design problem)
In GO multiple return values are mainly used to handle errors.

```go
f, err := os.ReadFile("/tmp/dat") // returns a file content and an error
```

A function returning a value and an error is a clearly a GO idiom:
```go
v, err := functionReturningAValueAndAnError(...) 
```

Well... half of the idiom because its full version is

```go
v, err := functionReturningAValueAndAnError() 
if err != nil { 
	// handle the error
}
```

The verbosity of the error handling idiom is one of the negative remarks people makes about GO.

Personally, I do not find the error handling idiom verbose. 
My main concern about function returning and extra error value is how it hinders function composition.
Let's modify a little bit our example of points and random coords. 
Let's say the function `randomCoords` can also return an error

```go
func randomCoords() (int, int, error) { ... }
```

Now our composition `newPoint(randomCoords())` does not compile any more:
`newPoint` expects two parameters but `randomCoords` returns three values.:boom:

We will see in the next pill how to solve this problem.

There are some language constructions, other than functions, that evaluate to more than one value.
For example accessing an entry of a map returns two values:

```go
m := map[int]string{1: "one", 2: "two", 3: "three"}
v, exists := m[2]
fmt.Printf("%q %v\n", v, exists) // "two" true
v, exists = m[5]
fmt.Printf("%q %v\n", v, exists) // "" false
```

:broken_heart: Ugliness: the second value is somewhat "optional" :astonished:
```go
v = m[2]
fmt.Printf("%q\n", v)    	// "two"
fmt.Printf("%q\n", m[2]) 	// "two"
fmt.Printf("%d %q\n", m[2])	// %!d(string=two) %!q(MISSING)
v = m[5]
fmt.Printf("%q\n", v)    	// ""
```

Other GO construction returning more than one value is `for-range`
```go
m := map[int]string{1: "one", 2: "two", 3: "three"}
for key, value := range m {
	println(key, value)
						// 1 one
						// 2 two
						// 3 three
}
```
:broken_heart: Ugliness: again, the second value is "optional"
```go
for key := range m {
	println(key)
				// 1
				// 2
				// 3
}
```

## :pill: #4: Adapter functions (with a touch of generics)

In the previous pill we saw how to compose functions like in 
```go
func newPoint(x, y int) point { return point{x, y} }
func randomCoords() (int, int) { ... }
...
newPoint(randomCoords())
```
We also saw how multiple return values are used mainly to return errors like in
```go
f, err := os.Open("/tmp/dat")
```
And how these error values prevent easily composing function calls.
For example:

```go
_, err:= io.Copy(
			os.Create("/tmp/dst.txt"),
			os.Open("/tmp/src.txt")
		)
```
will not compile. 
To make it work we could add some temp variables to write something like 

```go
source, _ := os.Open("/tmp/src.txt")
destination, _ := os.Create("/tmp/dst.txt")
io.Copy(destination,source)
```
But ignoring errors (the `_` in the left-hand-side of the assignment) is not nice.
So we end with something like:

```go
source, err := os.Open("/tmp/src.txt")
if err != nil { ... }
destination, err := os.Create("/tmp/dst.txt")
if err != nil { ... }
_, err = io.Copy(destination,source)
if err != nil { ... }
```

That is why people says error handling is verbose in GO.
In the previous pill I've said I'm comfortable with the GO's approach with error handling. 
Of course, others are not.
The subject was at the center of debates in the GO community, and some proposals to change error handling were made but rejected by the GO team.

Returning to our initial problem.
We want to call 
```go
io.Copy(os.Create("/tmp/dst.txt"),os.Open("/tmp/src.txt"))
```
but it does not work because the expected parameters of `io.Copy` do not match with those we are providing and we get a nice compiler error:
```
multiple-value os.Create("/tmp/dst.txt") (value of type (*os.File, error)) in single-value context
multiple-value os.Open("/tmp/src.txt") (value of type (*os.File, error)) in single-value context
```
in other words: _you are providing two values where the function expects only one_

If we make disappear those `error` return values then expected and provided parameters will match.
But how?
We will introduce an _adapter function_ that will... eh... adapt the results of `os.Create` and `os.Open` to match those expected by `io.Copy`.
Because all we need to do is remove the error return value, our adapter function will be named `noErr` and its definition is: 

```go
func noErr(f *os.File, err error) *os.File {
	return f
}
```
The adapter takes two arguments, an `*os.File` and an `error` to only return the first.

Now we can do:
```go
io.Copy(
	noErr(os.Create("/tmp/dst.txt")), 
	noErr(os.Open("/tmp/src.txt"))
)
```

Nice! :happy:... 

eh...

Nice? :thinking:
Not nice at all.
We are dropping the error and that, as said before, is ugly, very ugly.

We could handle the error in the adapter!
```go
func try(f *os.File, err error) *os.File {
	if err != nil {
		panic(err)
	}

	return f
}
```
(I've renamed the adapter, I think _try_ is now a better name)

Now we can write:
```go
io.Copy(
	try(os.Create("/tmp/dst.txt")), 
	try(os.Open("/tmp/src.txt"))
)
```
And errors are no more dropped.
If when creating or opening a file we get an error, the program will panic.
(panic-ing might not be so cool, I will talk about that in a future pill)

In fact what we will write is:
```go
_, err := io.Copy(
		try(os.Create("/tmp/dst.txt")), 
		try(os.Open("/tmp/src.txt"))
	)
if err != nil { ... }
```

Could we use the `try` function again and write:
```go
try(io.Copy(
	try(os.Create("/tmp/dst.txt")), 
	try(os.Open("/tmp/src.txt"))
))
```
No :-1: because `io.Copy` returns values (`int64, error`) not compatible with those expected by `try` (`*os.File, error`)
Wait a minute! 
Are we saying our `try` adapter only adapts functions returning `*os.File` and `error`?
Yes, that is the signature of our adapter.
So, if we want to adapt other types we need to declare new adapters?
Yes. 
For example the `try` version for `io.Copy` could be:
```go
func try2(v int64, err error) *os.File {
	if err != nil {
		panic(err)
	}

	return v
}
```

Beyond needing to find a new name for the new _try_ function I'm sure you agree with me on the fact that defining a new version of _try_ for each combination of a type and an `error` does not scale well.

There is still hope!

Re-reading me... "_defining a new version of _try_ for each combination of a type and an `error`_"... "_combination of a type and an `error`_"... "_type and an `error`_"

We can use generics!

With generics we can define a, well, generic function that can be parametrized with the type we need to adapt.

```go
func try[T any](v T, err error) T {
	if err != nil {
		panic(err)
	}

	return v
}
```
Now `try` accepts a value of some type `T` (we do not know yet) and an `error`. 
Thus the following calls are now valid:

```go
try(
	io.Copy(
		try(os.Create("/tmp/dst.txt")), 
		try(os.Open("/tmp/src.txt"))
	)
)
```
And others like
```go
jsn := try(json.Marshal(myStruct)) // Marshal returns ([]byte, error)
t := try(http.ParseTime(text)) // ParseTime returns (t time.Time, err error)
r := try(httpClient.Get(url)) // Get returns (resp *Response, err error)
```

I do not use this hack and I do not recommend using it.
I used error handling as an example, _adapter functions_ have other, more _morally_ acceptable uses. 
