---
layout: post
tag: go-pills golang go
---
![pills all over there](pills-header.png)
# GO Programming Pills

* TOC
{:toc}

## :pill: #1: Forcing to use field names when instantiating structs

In GO, when instantiating a struct type you can use:
* _named fields_:  you name the fields you are assigning a value to, or
* _positional fields_: you let the position of the instantiation values define which field they correspond to

For example:

```go
type position struct {
	x int
	y int
}

func main() {
	p1 := position{y: 5, x: 10} // named instantiation
	p2 := position{10, 5}       // positional instantiation

	fmt.Printf("%+v == %+v", p1, p2)
}
```

The output of [executing the above code](https://go.dev/play/p/W6WWNrVgaJB) is:

```
{x:10 y:5} == {x:10 y:5}
```

Each initialization approach has its pros and cons and is up to you to decide which one to use when instantiating a struct type.

In cases like the above example, using positional initialization can lead to subtle bugs because the type of the two fields is the same, thus we can mix their values inadvertently when doing the instantiation.
As the developer of the type you might avoid instantiation errors by forcing users to use _named fields_... but how?!

Well there is a little hack: add a field with a blank (`_`) identifier at the beginning of the struct

```go
type position struct {
	_ struct{}  // just to force named fields in instantiation
	x int
	y int
}
```

Now, if you try to [run the code](https://go.dev/play/p/MXaGWWNxqMw) you will get the following **compilation** error for the expression `position{10, 5}`:

```
cannot use 10 (untyped int constant) as struct{} value in struct literal
too few values in struct literal
```

That does the trick and users will need (or prefer) to use named fields when instantiating your struct.

Anyway, do not forget that it is a _hack_ and that the compile error might be a little cryptic for some people.
Personally I prefer to use constructors even if they are not idiomatic in GO.

## :pill: #2: Are your struct tags OK?

In GO, _struct tags_ are used to annotate struct fields with meta-information.
Usually the meta-information helps data transformation libraries to marshall/unmarshall structs to/from some data representation format like JSON, XML, YAML, ...

For example, the following struct is annotated with meta-information for JSON and XML transformations:

```go
type User struct {
	ID   string `json:"id" xml:"identifier"`
	Name string `json:"name" xml:"name"`
}
```

Struct tags are one of the few ugliness of GO.
Tags are strings interpreted at runtime by using reflection.
Consequence: **the compiler is unable to catch errors in struct tags** :disappointed:

One very frequent error is JSON marshaling tags including `inline` option. For example:

```go
type UserContainer struct {
	apiv1.Container `json:",inline" protobuf:"bytes,1,opt,name=container"`
	// ...
}
```
([Argo](https://github.com/argoproj/argo-workflows/blob/1f1a1e0e9bfd1d6fe54146abd85e15ba80885768/pkg/apis/workflow/v1alpha1/workflow_types.go#L1516){:target="_blank" rel="noopener"})

```go
type ResourceMeta struct {
	TypeMeta `json:",inline" yaml:",inline"`
	// ...
}
```
([Kustomize](https://github.com/kubernetes-sigs/kustomize/blob/2fe04496c285bc2fa7a7233a7a584ab96e21f88d/kyaml/yaml/types.go#L139){:target="_blank" rel="noopener"})

The problem: `inline` option is not recognized by the standard [JSON library](https://pkg.go.dev/encoding/json), 
thus using it means nothing!

Another common problem in struct tags are typos.
Can you spot the problem in the code below?
```go
type LogicalProcessor struct {
        LpIndex     uint32 `json:"LogicalProcessorCount,omitempty"`
        NodeNumber  uint8  `json:"NodeNumber,omitempty"`
        PackageId   uint32 `json:"PackageId,omitemty"`
        CoreId      uint32 `json:"CoreId,omitempty"`
        RootVpIndex int32  `json:"RootVpIndex,omitempty"`
}
```
Did you see it?
The `omitem[p]ty` at the third field? :wink:

And to make things worst, using spaces in tags is tricky:
```go
`json:"metadata,omitempty"`  // OK
`json: "metadata,omitempty"` // Not OK
`json:"metadata, omitempty"` // Not OK
```
:scream: 
([here](https://go.dev/play/p/SYtEPFJUL_a){:target="_blank" rel="noopener"} you can see these problems in action)

As said before, the GO compiler will not help us with that.

We can use static code analysis tools (like [Revive](https://github.com/mgechev/revive){:target="_blank" rel="noopener"}) to detect these problems.
